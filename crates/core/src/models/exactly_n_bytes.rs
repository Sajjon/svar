use crate::prelude::*;

pub type Exactly32Bytes = ExactlyNBytes<32>;
pub type Exactly16Bytes = ExactlyNBytes<16>;
pub type Exactly12Bytes = ExactlyNBytes<12>;

/// A type that represents a byte array of exactly N bytes.
#[derive(
    Zeroize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    Ord,
    PartialOrd,
    SerializeDisplay,
    DeserializeFromStr,
    derive_more::Display,
    derive_more::From,
    derive_more::Debug,
)]
#[display("{}", self.to_hex())]
#[debug("{}", self.to_hex())]
pub struct ExactlyNBytes<const N: usize>(pub [u8; N]);

use std::str::FromStr;
impl<const N: usize> std::str::FromStr for ExactlyNBytes<N> {
    type Err = crate::Error;

    fn from_str(s: &str) -> Result<Self> {
        hex_decode(s)
            .map_err(|e| Error::InvalidHex {
                underlying: e.to_string(),
            })
            .and_then(Self::try_from)
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    pub fn bytes(&self) -> &[u8; N] {
        &self.0
    }

    pub fn xor(&self, other: &Self) -> Self {
        let mut result = [0u8; N];
        for (i, item) in result.iter_mut().enumerate().take(N) {
            *item = self.0[i] ^ other.0[i];
        }
        Self(result)
    }

    /// Instantiates a new `ExactlyNBytes<N>` from bytes generated by
    /// a CSPRNG.
    pub fn generate() -> Self {
        Self::from(&generate_byte_array::<N>())
    }

    /// Tries to decode the string `s` into this type. Will fail
    // if the string is not valid hex or if the decoded bytes does
    // not have length `N`.
    pub fn from_hex(s: &str) -> Result<Self> {
        Self::from_str(s)
    }

    pub fn to_hex(self) -> String {
        hex_encode(self.0)
    }

    pub fn to_vec(self) -> Vec<u8> {
        self.0.to_vec()
    }
}

impl<const N: usize> TryFrom<&[u8]> for ExactlyNBytes<N> {
    type Error = crate::Error;

    fn try_from(value: &[u8]) -> Result<Self> {
        if value.len() == N {
            Ok(Self(value.try_into().unwrap()))
        } else {
            Err(Error::InvalidByteCount {
                expected: N,
                found: value.len(),
            })
        }
    }
}

impl<const N: usize> TryFrom<Vec<u8>> for ExactlyNBytes<N> {
    type Error = crate::Error;

    fn try_from(value: Vec<u8>) -> Result<Self> {
        Self::try_from(value.as_slice())
    }
}

impl<const N: usize> AsRef<[u8]> for ExactlyNBytes<N> {
    fn as_ref(&self) -> &[u8] {
        self.bytes()
    }
}

impl<const N: usize> From<&[u8; N]> for ExactlyNBytes<N> {
    fn from(value: &[u8; N]) -> Self {
        Self(*value)
    }
}

impl<const N: usize> HasSampleValues for ExactlyNBytes<N> {
    /// `deadbeef...``
    /// A sample used to facilitate unit tests.
    fn sample() -> Self {
        Self::sample_dead()
    }

    /// A sample used to facilitate unit tests.
    fn sample_other() -> Self {
        Self::sample_fade()
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    fn declare_sample(r: &str) -> Self {
        let mut s = r.repeat(N).to_owned();
        let target_len = N * 2;

        if s.len() != target_len {
            s.truncate(target_len);
        }
        Self::from_str(&s).expect("Valid sample")
    }

    /// `aced...``
    /// A sample used to facilitate unit tests.
    pub fn sample_aced() -> Self {
        Self::declare_sample("aced")
    }

    /// `babe...``
    /// A sample used to facilitate unit tests.
    pub fn sample_babe() -> Self {
        Self::declare_sample("babe")
    }

    /// `cafe...``
    /// A sample used to facilitate unit tests.
    pub fn sample_cafe() -> Self {
        Self::declare_sample("cafe")
    }

    /// `dead...``
    /// A sample used to facilitate unit tests.
    pub fn sample_dead() -> Self {
        Self::declare_sample("dead")
    }

    /// `ecad...``
    /// A sample used to facilitate unit tests.
    pub fn sample_ecad() -> Self {
        Self::declare_sample("ecad")
    }

    /// `fade...``
    /// A sample used to facilitate unit tests.
    pub fn sample_fade() -> Self {
        Self::declare_sample("fade")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use test_log::test;

    type Sut = ExactlyNBytes<8>;

    #[test]
    fn equality() {
        assert_eq!(Sut::sample(), Sut::sample());
        assert_eq!(Sut::sample_other(), Sut::sample_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(Sut::sample(), Sut::sample_other());
    }

    #[test]
    fn try_from_wrong_length() {
        let result: Result<Sut> = Sut::try_from(vec![1, 2, 3]);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            Error::InvalidByteCount {
                expected: 8,
                found: 3
            }
        );
    }

    #[test]
    fn declare_sample_wrong_rounded_length() {
        assert_eq!(Sut::declare_sample("deaddead"), Sut::sample_dead());
        assert_eq!(Sut::declare_sample("de").to_string(), "dededededededede");
    }

    #[test]
    fn from_hex_success() {
        let hex = "deaddeaddeaddead";
        let result: Result<Sut> = Sut::from_hex(hex);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Sut::sample_dead());
    }

    #[test]
    fn from_hex_invalid() {
        let hex = "invalidhex";
        let result: Result<Sut> = Sut::from_hex(hex);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid hex"));
    }

    #[test]
    fn xor() {
        let a = ExactlyNBytes::<1>::from_hex("f0").unwrap();
        let b = ExactlyNBytes::<1>::from_hex("0f").unwrap();
        assert_eq!(a.xor(&b), ExactlyNBytes::<1>::from_hex("ff").unwrap());
        assert_eq!(a.xor(&a), ExactlyNBytes::<1>::from_hex("00").unwrap());
        assert_eq!(b.xor(&b), ExactlyNBytes::<1>::from_hex("00").unwrap());
        assert_eq!(a.xor(&b), b.xor(&a)); // commutative
    }
}
